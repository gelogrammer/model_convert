// Database Fix Script for SpeechSense AI
const { createClient } = require('@supabase/supabase-js');

// Configuration - use the same values as in your .env file
const supabaseUrl = 'https://pztstrmccavxrgccvmjq.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB6dHN0cm1jY2F2eHJnY2N2bWpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU5MzExNDEsImV4cCI6MjA2MTUwNzE0MX0.a3fTAAaTip_DenzWBWBoTjRD-ARiZRdXqmwE7Rgz6Yg';

// Create the Supabase client
const supabase = createClient(supabaseUrl, supabaseKey);

// Function to check and create the bucket
async function checkAndCreateBucket() {
  console.log('Checking if recordings bucket exists...');
  
  try {
    const { data: bucketData, error: bucketError } = await supabase.storage.getBucket('recordings');
    
    if (bucketError && bucketError.message && (bucketError.message.includes('not found') || bucketError.message.includes('does not exist'))) {
      console.log('Recordings bucket not found. Creating bucket...');
      
      const { data: createData, error: createError } = await supabase.storage.createBucket('recordings', {
        public: true,
        allowedMimeTypes: ['audio/webm', 'audio/mpeg', 'audio/wav'],
        fileSizeLimit: 50000000 // 50MB
      });
      
      if (createError) {
        console.error('Failed to create bucket:', createError);
        return false;
      }
      
      console.log('Recordings bucket created successfully:', createData);
      
      // Create storage policies
      console.log('Setting up storage policies...');
      
      // We'll use SQL for this via RPC call
      const policySQL = `
        BEGIN;
        -- Policy for public viewing
        CREATE POLICY IF NOT EXISTS "Anyone can view recordings" 
        ON storage.objects FOR SELECT 
        USING (bucket_id = 'recordings');
        
        -- Policy for anonymous uploads (for testing)
        CREATE POLICY IF NOT EXISTS "Anonymous users can upload recordings" 
        ON storage.objects FOR INSERT 
        WITH CHECK (bucket_id = 'recordings');
        
        -- Policy for anonymous updates (for testing)
        CREATE POLICY IF NOT EXISTS "Anonymous users can update recordings" 
        ON storage.objects FOR UPDATE 
        USING (bucket_id = 'recordings');
        
        -- Policy for anonymous deletes (for testing)
        CREATE POLICY IF NOT EXISTS "Anonymous users can delete recordings" 
        ON storage.objects FOR DELETE 
        USING (bucket_id = 'recordings');
        COMMIT;
      `;
      
      const { error: policyError } = await supabase.rpc('exec_sql', { sql: policySQL });
      
      if (policyError) {
        console.warn('Error setting policies via RPC, but bucket was created:', policyError);
        console.log('You may need to manually set storage policies in the Supabase Dashboard');
      } else {
        console.log('Storage policies created successfully');
      }
      
      return true;
    } else if (bucketError) {
      console.error('Error checking bucket:', bucketError);
      return false;
    } else {
      console.log('Recordings bucket already exists:', bucketData);
      return true;
    }
  } catch (error) {
    console.error('Error in bucket check/creation:', error);
    return false;
  }
}

// Function to check and create the recordings table
async function checkAndCreateTable() {
  console.log('Checking if recordings table exists...');
  
  try {
    const { count, error: countError } = await supabase
      .from('recordings')
      .select('*', { count: 'exact', head: true });
      
    if (countError && countError.message && countError.message.includes('does not exist')) {
      console.log('Recordings table not found. Creating table...');
      
      // Using SQL via RPC to create the table
      const tableSQL = `
        BEGIN;
        
        -- Create the recordings table
        CREATE TABLE IF NOT EXISTS public.recordings (
          id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
          user_id uuid NULL DEFAULT auth.uid(),
          file_name text NOT NULL,
          file_path text NOT NULL,
          public_url text NOT NULL,
          duration bigint NOT NULL,
          recorded_at timestamp with time zone NULL DEFAULT now(),
          emotion_data jsonb NULL,
          created_at timestamp with time zone NULL DEFAULT now(),
          updated_at timestamp with time zone NULL DEFAULT now(),
          CONSTRAINT recordings_pkey PRIMARY KEY (id),
          CONSTRAINT recordings_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id)
        );
        
        -- Create trigger for updated_at if it doesn't exist
        CREATE OR REPLACE FUNCTION public.set_updated_at()
        RETURNS trigger AS $$
        BEGIN
          NEW.updated_at = now();
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        
        -- Drop trigger if it exists
        DROP TRIGGER IF EXISTS set_recordings_updated_at ON public.recordings;
        
        -- Create the trigger
        CREATE TRIGGER set_recordings_updated_at
        BEFORE UPDATE ON public.recordings
        FOR EACH ROW
        EXECUTE FUNCTION public.set_updated_at();
        
        -- Enable Row Level Security
        ALTER TABLE public.recordings ENABLE ROW LEVEL SECURITY;
        
        -- Create anonymous access policies (for testing)
        CREATE POLICY "Anonymous users can view recordings" 
        ON public.recordings FOR SELECT 
        TO anon
        USING (true);
        
        CREATE POLICY "Anonymous users can insert recordings" 
        ON public.recordings FOR INSERT 
        TO anon
        WITH CHECK (true);
        
        CREATE POLICY "Anonymous users can update recordings" 
        ON public.recordings FOR UPDATE 
        TO anon
        USING (true);
        
        CREATE POLICY "Anonymous users can delete recordings" 
        ON public.recordings FOR DELETE 
        TO anon
        USING (true);
        
        -- Create authenticated user policies
        CREATE POLICY "Users can view their own recordings" 
        ON public.recordings FOR SELECT 
        TO authenticated
        USING (user_id = auth.uid());
        
        CREATE POLICY "Users can insert their own recordings" 
        ON public.recordings FOR INSERT 
        TO authenticated
        WITH CHECK (user_id = auth.uid());
        
        CREATE POLICY "Users can update their own recordings" 
        ON public.recordings FOR UPDATE 
        TO authenticated
        USING (user_id = auth.uid());
        
        CREATE POLICY "Users can delete their own recordings" 
        ON public.recordings FOR DELETE 
        TO authenticated
        USING (user_id = auth.uid());
        
        COMMIT;
      `;
      
      const { error: sqlError } = await supabase.rpc('exec_sql', { sql: tableSQL });
      
      if (sqlError) {
        console.error('Failed to create recordings table via RPC:', sqlError);
        
        if (sqlError.message && sqlError.message.includes('function "exec_sql" does not exist')) {
          console.log('The exec_sql function is not available. You need to manually run the SQL from direct_create_recordings.sql');
        }
        
        return false;
      }
      
      console.log('Recordings table created successfully');
      return true;
    } else if (countError) {
      console.error('Error checking table:', countError);
      return false;
    } else {
      console.log(`Recordings table already exists with approximately ${count} records`);
      return true;
    }
  } catch (error) {
    console.error('Error in table check/creation:', error);
    return false;
  }
}

// Main function
async function fixDatabase() {
  console.log('Starting database fix process...');
  
  // Step 1: Check Supabase connection
  try {
    const { data, error } = await supabase.auth.getSession();
    
    console.log('Supabase connection test:', error ? 'Failed' : 'Successful');
    console.log('Session data:', data);
    
    if (error) {
      console.error('Connection error:', error);
      return;
    }
  } catch (error) {
    console.error('Error testing Supabase connection:', error);
    return;
  }
  
  // Step 2: Create the bucket
  const bucketResult = await checkAndCreateBucket();
  
  // Step 3: Create the table
  const tableResult = await checkAndCreateTable();
  
  // Step 4: Report results
  console.log('\n--- DATABASE FIX RESULTS ---');
  console.log('Storage bucket setup:', bucketResult ? 'SUCCESSFUL' : 'FAILED');
  console.log('Recordings table setup:', tableResult ? 'SUCCESSFUL' : 'FAILED');
  
  if (bucketResult && tableResult) {
    console.log('\n✅ DATABASE SETUP COMPLETE!');
    console.log('Your SpeechSense AI application should now be able to save and fetch recordings.');
    console.log('Please restart the application and try again.');
  } else {
    console.log('\n⚠️ DATABASE SETUP INCOMPLETE');
    console.log('Some steps failed. Please check the errors above and try again.');
    console.log('Alternatively, follow the instructions in setup_instructions.txt to manually fix the database.');
  }
}

// Run the fix
fixDatabase().catch(err => {
  console.error('Unhandled error in database fix script:', err);
}); 