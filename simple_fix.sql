-- SIMPLE FIX FOR SPEECHSENSE AI DATABASE ISSUES
-- Copy this entire file and paste it into Supabase SQL Editor

-- Create recordings bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, public)
VALUES ('recordings', 'recordings', true)
ON CONFLICT (id) DO NOTHING;

-- Update bucket settings
UPDATE storage.buckets 
SET public = true,
    file_size_limit = 52428800,
    allowed_mime_types = ARRAY['audio/webm', 'audio/mpeg', 'audio/wav', 'audio/mp3']
WHERE id = 'recordings';

-- Create recordings table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.recordings (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  user_id uuid NULL DEFAULT auth.uid(),
  file_name text NOT NULL,
  file_path text NOT NULL,
  public_url text NOT NULL,
  duration bigint NOT NULL,
  recorded_at timestamp with time zone NULL DEFAULT now(),
  emotion_data jsonb NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  updated_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT recordings_pkey PRIMARY KEY (id),
  CONSTRAINT recordings_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id)
);

-- Create updated_at trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger if it doesn't exist already
DROP TRIGGER IF EXISTS set_recordings_updated_at ON public.recordings;
CREATE TRIGGER set_recordings_updated_at
BEFORE UPDATE ON public.recordings
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at();

-- Enable Row Level Security
ALTER TABLE public.recordings ENABLE ROW LEVEL SECURITY;

-- Drop ALL existing policies for recordings table and storage
DO $$ 
BEGIN
    -- TABLE POLICIES
    -- Drop recording table policies
    BEGIN DROP POLICY IF EXISTS "Anonymous users can select recordings" ON public.recordings; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can insert recordings" ON public.recordings; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can update recordings" ON public.recordings; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can delete recordings" ON public.recordings; EXCEPTION WHEN undefined_object THEN NULL; END;
    
    -- STORAGE POLICIES
    -- Drop storage object policies
    BEGIN DROP POLICY IF EXISTS "Anyone can view recordings" ON storage.objects; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anyone can insert recordings" ON storage.objects; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can upload recordings" ON storage.objects; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can update recordings" ON storage.objects; EXCEPTION WHEN undefined_object THEN NULL; END;
    BEGIN DROP POLICY IF EXISTS "Anonymous users can delete recordings" ON storage.objects; EXCEPTION WHEN undefined_object THEN NULL; END;
END $$;

-- Create comprehensive anonymous policies for recordings table
CREATE POLICY "Anonymous users can select recordings"
ON public.recordings FOR SELECT
TO anon
USING (true);

CREATE POLICY "Anonymous users can insert recordings"
ON public.recordings FOR INSERT
TO anon
WITH CHECK (true);

CREATE POLICY "Anonymous users can update recordings"
ON public.recordings FOR UPDATE
TO anon
USING (true);

CREATE POLICY "Anonymous users can delete recordings"
ON public.recordings FOR DELETE
TO anon
USING (true);

-- Create comprehensive storage policies
CREATE POLICY "Anyone can view recordings"
ON storage.objects FOR SELECT
USING (bucket_id = 'recordings');

CREATE POLICY "Anonymous users can upload recordings"
ON storage.objects FOR INSERT
TO anon
WITH CHECK (bucket_id = 'recordings');

CREATE POLICY "Anonymous users can update recordings"
ON storage.objects FOR UPDATE
TO anon
USING (bucket_id = 'recordings');

CREATE POLICY "Anonymous users can delete recordings"
ON storage.objects FOR DELETE
TO anon
USING (bucket_id = 'recordings');

-- DONE! The database should now be fixed. 