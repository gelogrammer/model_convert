-- Combined SQL for deployment 
 
-- Create this function in your Supabase SQL editor
-- This must be run as an admin/superuser

CREATE OR REPLACE FUNCTION create_recordings_table_if_not_exists()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER -- This is important - runs with definer privileges
AS $$
DECLARE
  table_exists boolean;
  result json;
BEGIN
  -- Check if table exists
  SELECT EXISTS (
    SELECT FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_name = 'recordings'
  ) INTO table_exists;
  
  -- Create table if it doesn't exist
  IF NOT table_exists THEN
    -- Create the recordings table
    CREATE TABLE public.recordings (
      id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
      user_id uuid NULL DEFAULT auth.uid(),
      file_name text NOT NULL,
      file_path text NOT NULL,
      public_url text NOT NULL,
      duration bigint NOT NULL,
      recorded_at timestamp with time zone NULL DEFAULT now(),
      emotion_data jsonb NULL,
      created_at timestamp with time zone NULL DEFAULT now(),
      updated_at timestamp with time zone NULL DEFAULT now(),
      CONSTRAINT recordings_pkey PRIMARY KEY (id),
      CONSTRAINT recordings_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id)
    ) TABLESPACE pg_default;
    
    -- Create trigger for updated_at
    CREATE OR REPLACE FUNCTION public.set_updated_at()
    RETURNS trigger AS $$
    BEGIN
      NEW.updated_at = now();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    
    CREATE TRIGGER set_recordings_updated_at
    BEFORE UPDATE ON public.recordings
    FOR EACH ROW
    EXECUTE FUNCTION public.set_updated_at();
    
    -- Enable Row Level Security
    ALTER TABLE public.recordings ENABLE ROW LEVEL SECURITY;
    
    -- Create RLS policies
    CREATE POLICY "Users can view their own recordings" 
    ON public.recordings FOR SELECT 
    USING (user_id = auth.uid());
    
    CREATE POLICY "Users can insert their own recordings" 
    ON public.recordings FOR INSERT 
    WITH CHECK (user_id = auth.uid());
    
    CREATE POLICY "Users can update their own recordings" 
    ON public.recordings FOR UPDATE 
    USING (user_id = auth.uid());
    
    CREATE POLICY "Users can delete their own recordings" 
    ON public.recordings FOR DELETE 
    USING (user_id = auth.uid());
    
    -- Anonymous policies for development/testing
    CREATE POLICY "Anonymous users can view recordings" 
    ON public.recordings FOR SELECT 
    TO anon
    USING (true);
    
    CREATE POLICY "Anonymous users can insert recordings" 
    ON public.recordings FOR INSERT 
    TO anon
    WITH CHECK (true);
    
    CREATE POLICY "Anonymous users can update recordings" 
    ON public.recordings FOR UPDATE 
    TO anon
    USING (true);
    
    CREATE POLICY "Anonymous users can delete recordings" 
    ON public.recordings FOR DELETE 
    TO anon
    USING (true);
    
    result := json_build_object('success', true, 'message', 'Recordings table created successfully');
  ELSE
    result := json_build_object('success', true, 'message', 'Recordings table already exists');
  END IF;
  
  RETURN result;
END;
$$;

-- Grant permission to execute this function to authenticated and anonymous users
GRANT EXECUTE ON FUNCTION create_recordings_table_if_not_exists() TO authenticated;
GRANT EXECUTE ON FUNCTION create_recordings_table_if_not_exists() TO anon;  
 
-- Create this function in your Supabase SQL editor
-- This must be run as an admin/superuser

CREATE OR REPLACE FUNCTION create_recordings_bucket_if_not_exists()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER -- This is important - runs with definer privileges
AS $$
DECLARE
  bucket_exists boolean;
  result json;
BEGIN
  -- Check if bucket exists
  SELECT EXISTS (
    SELECT 1 FROM storage.buckets WHERE name = 'recordings'
  ) INTO bucket_exists;
  
  -- Create bucket if it doesn't exist
  IF NOT bucket_exists THEN
    -- Create the bucket
    INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
    VALUES (
      'recordings',
      'recordings',
      true,
      52428800, -- 50MB file size limit
      '{audio/webm,audio/mp3,audio/mpeg,audio/wav}'
    );
    
    -- Create storage policies
    -- Policy for public viewing
    EXECUTE 'CREATE POLICY "Anyone can view recordings" ON storage.objects FOR SELECT USING (bucket_id = ''recordings'')';
    
    -- Policy for anonymous uploads (for testing)
    EXECUTE 'CREATE POLICY "Anonymous users can upload recordings" ON storage.objects FOR INSERT WITH CHECK (bucket_id = ''recordings'')';
    
    -- Policy for anonymous updates (for testing)
    EXECUTE 'CREATE POLICY "Anonymous users can update recordings" ON storage.objects FOR UPDATE USING (bucket_id = ''recordings'')';
    
    -- Policy for anonymous deletes (for testing)
    EXECUTE 'CREATE POLICY "Anonymous users can delete recordings" ON storage.objects FOR DELETE USING (bucket_id = ''recordings'')';
    
    -- Policy for authenticated users
    EXECUTE 'CREATE POLICY "Authenticated users can upload recordings" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = ''recordings'')';
    
    -- Policy for authenticated users to update their own recordings
    EXECUTE 'CREATE POLICY "Users can update their own recordings" ON storage.objects FOR UPDATE TO authenticated USING (bucket_id = ''recordings'' AND owner = auth.uid())';
    
    -- Policy for authenticated users to delete their own recordings
    EXECUTE 'CREATE POLICY "Users can delete their own recordings" ON storage.objects FOR DELETE TO authenticated USING (bucket_id = ''recordings'' AND owner = auth.uid())';
    
    result := json_build_object('success', true, 'message', 'Recordings bucket created successfully');
  ELSE
    result := json_build_object('success', true, 'message', 'Recordings bucket already exists');
  END IF;
  
  RETURN result;
END;
$$;

-- Grant permission to execute this function to authenticated and anonymous users
GRANT EXECUTE ON FUNCTION create_recordings_bucket_if_not_exists() TO authenticated;
GRANT EXECUTE ON FUNCTION create_recordings_bucket_if_not_exists() TO anon; 